"""
Local Volatility Computation from SVI and SSVI Models

This module implements the Dupire formula to compute local volatility from implied volatility
surfaces generated by SVI and SSVI models. The local volatility function σ_LV(S,t) describes
the instantaneous volatility of the underlying asset as a function of spot price and time.

Mathematical Background:
The Dupire formula relates local volatility to implied volatility and its derivatives:

σ_LV²(K,T) = (∂C/∂T + rK∂C/∂K) / (½K²∂²C/∂K²)

Where C(K,T) is the call option price. In terms of implied volatility σ_IV(K,T):

σ_LV²(K,T) = (∂w/∂T) / (1 - y/(w)*(∂w/∂y) + ¼*(-¼ - 1/w + (y/w)²)*(∂w/∂y)² + ½*(∂²w/∂y²))

Where:
- w(y,T) = σ_IV²(K,T) * T is total variance
- y = ln(K/S₀) is log-moneyness (assuming zero interest rate and dividend)
- The denominator is related to the risk-neutral density

References:
- Dupire, B. (1994). Pricing with a smile. Risk, 7(1), 18-20.
- Gatheral, J. (2006). The Volatility Surface: A Practitioner's Guide.
"""

import numpy as np
from scipy.optimize import minimize_scalar
import warnings
from typing import Tuple, Optional, Callable

from svi_models import compute_svi_total_variance, compute_ssvi_total_variance


def compute_svi_total_variance_derivatives(k_values, a, b, rho, m, sigma):
    """
    Compute SVI total variance and its first and second derivatives with respect to log-moneyness.
    
    For SVI: w(k) = a + b * (rho * (k - m) + sqrt((k - m)² + sigma²))
    
    Parameters
    ----------
    k_values : ndarray
        1-D array of log-moneyness values.
    a, b, rho, m, sigma : float
        SVI parameters.
    
    Returns
    -------
    w : ndarray
        Total variance w(k).
    w_prime : ndarray  
        First derivative ∂w/∂k.
    w_double_prime : ndarray
        Second derivative ∂²w/∂k².
    """
    diff = k_values - m
    sqrt_term = np.sqrt(diff**2 + sigma**2)
    
    # Total variance
    w = a + b * (rho * diff + sqrt_term)
    
    # First derivative: ∂w/∂k
    w_prime = b * (rho + diff / sqrt_term)
    
    # Second derivative: ∂²w/∂k²
    w_double_prime = b * sigma**2 / (sqrt_term**3)
    
    return w, w_prime, w_double_prime


def compute_ssvi_total_variance_derivatives(k_values, theta, phi, rho):
    """
    Compute SSVI total variance and its derivatives with respect to log-moneyness.
    
    For SSVI: w(k) = 0.5 * theta * (1 + rho * phi * k + sqrt((phi * k + rho)² + 1 - rho²))
    
    Parameters
    ----------
    k_values : ndarray
        1-D array of log-moneyness values.
    theta, phi, rho : float
        SSVI parameters.
    
    Returns
    -------
    w : ndarray
        Total variance w(k).
    w_prime : ndarray
        First derivative ∂w/∂k.
    w_double_prime : ndarray
        Second derivative ∂²w/∂k².
    """
    phi_k = phi * k_values
    inside = (phi_k + rho)**2 + 1 - rho**2
    sqrt_term = np.sqrt(np.maximum(inside, 1e-10))  # Numerical stability
    
    # Total variance
    w = 0.5 * theta * (1 + rho * phi_k + sqrt_term)
    
    # First derivative: ∂w/∂k
    w_prime = 0.5 * theta * phi * (rho + (phi_k + rho) / sqrt_term)
    
    # Second derivative: ∂²w/∂k²
    numerator = (1 - rho**2) * phi**2
    denominator = sqrt_term**3
    w_double_prime = 0.5 * theta * numerator / denominator
    
    return w, w_prime, w_double_prime


def dupire_local_volatility_from_total_variance(k_values, T, w, w_prime, w_double_prime, 
                                              dw_dT=None, r=0.0):
    """
    Compute local volatility using the Dupire formula in terms of total variance.
    
    The Dupire formula in total variance form:
    σ_LV²(k,T) = (∂w/∂T + r*w) / (1 - k/(2w)*∂w/∂k + ¼*(-¼ - 1/w + k²/(4w²))*(∂w/∂k)² + ½*∂²w/∂k²)
    
    For SVI/SSVI models, the total variance is w(k,T) = T * w_svi(k) where w_svi(k) is the 
    SVI parameterization. This means ∂w/∂T = w_svi(k) = w(k,T)/T.
    
    Parameters
    ----------
    k_values : ndarray
        Log-moneyness values.
    T : float
        Time to maturity.
    w : ndarray
        Total variance w(k,T).
    w_prime : ndarray
        First derivative ∂w/∂k.
    w_double_prime : ndarray
        Second derivative ∂²w/∂k².
    dw_dT : ndarray, optional
        Time derivative ∂w/∂T. If None, assumes w(k,T) = T * w_svi(k), so ∂w/∂T = w/T.
    r : float, optional
        Risk-free interest rate. Default is 0.
    
    Returns
    -------
    local_vol : ndarray
        Local volatility σ_LV(k,T).
    is_valid : ndarray
        Boolean array indicating where local volatility is well-defined and positive.
    """
    # Ensure positive total variance and time for numerical stability
    w_safe = np.maximum(w, 1e-8)
    T_safe = max(T, 1e-8)
    
    # Numerator: ∂w/∂T + r*w
    if dw_dT is not None:
        numerator = dw_dT + r * w_safe
    else:
        # For SVI/SSVI: w(k,T) = T * w_svi(k), so ∂w/∂T = w_svi(k) = w(k,T)/T
        numerator = w_safe / T_safe + r * w_safe
    
    # Denominator terms
    term1 = 1.0
    term2 = -k_values / (2 * w_safe) * w_prime
    
    # The tricky term: ¼*(-¼ - 1/w + k²/(4w²))*(∂w/∂k)²
    bracket = -0.25 - 1/w_safe + (k_values**2) / (4 * w_safe**2)
    term3 = 0.25 * bracket * (w_prime**2)
    
    term4 = 0.5 * w_double_prime
    
    denominator = term1 + term2 + term3 + term4
    
    # Check for positive denominator (no arbitrage condition)
    is_valid = (denominator > 1e-10) & (numerator > 0) & (w_safe > 1e-8)
    
    # Compute local volatility
    local_vol_squared = np.where(is_valid, numerator / denominator, np.nan)
    local_vol = np.sqrt(np.maximum(local_vol_squared, 0))
    
    return local_vol, is_valid


def compute_svi_local_volatility(k_values, T, a, b, rho, m, sigma, r=0.0):
    """
    Compute local volatility from SVI model parameters.
    
    Parameters
    ----------
    k_values : ndarray
        Log-moneyness values.
    T : float
        Time to maturity.
    a, b, rho, m, sigma : float
        SVI parameters.
    r : float, optional
        Risk-free interest rate. Default is 0.
    
    Returns
    -------
    local_vol : ndarray
        Local volatility σ_LV(k,T).
    is_valid : ndarray
        Boolean array indicating where local volatility is well-defined.
    diagnostics : dict
        Dictionary containing intermediate calculations for debugging.
    """
    # Compute total variance and derivatives
    w, w_prime, w_double_prime = compute_svi_total_variance_derivatives(
        k_values, a, b, rho, m, sigma
    )
    
    # Compute local volatility using Dupire formula
    local_vol, is_valid = dupire_local_volatility_from_total_variance(
        k_values, T, w, w_prime, w_double_prime, r=r
    )
    
    # Store diagnostics
    diagnostics = {
        'total_variance': w,
        'first_derivative': w_prime,
        'second_derivative': w_double_prime,
        'parameters': {'a': a, 'b': b, 'rho': rho, 'm': m, 'sigma': sigma, 'T': T, 'r': r}
    }
    
    return local_vol, is_valid, diagnostics


def compute_ssvi_local_volatility(k_values, T, theta, phi, rho, r=0.0):
    """
    Compute local volatility from SSVI model parameters.
    
    Parameters
    ----------
    k_values : ndarray
        Log-moneyness values.
    T : float
        Time to maturity.
    theta, phi, rho : float
        SSVI parameters.
    r : float, optional
        Risk-free interest rate. Default is 0.
    
    Returns
    -------
    local_vol : ndarray
        Local volatility σ_LV(k,T).
    is_valid : ndarray
        Boolean array indicating where local volatility is well-defined.
    diagnostics : dict
        Dictionary containing intermediate calculations for debugging.
    """
    # Compute total variance and derivatives
    w, w_prime, w_double_prime = compute_ssvi_total_variance_derivatives(
        k_values, theta, phi, rho
    )
    
    # Compute local volatility using Dupire formula
    local_vol, is_valid = dupire_local_volatility_from_total_variance(
        k_values, T, w, w_prime, w_double_prime, r=r
    )
    
    # Store diagnostics
    diagnostics = {
        'total_variance': w,
        'first_derivative': w_prime,
        'second_derivative': w_double_prime,
        'parameters': {'theta': theta, 'phi': phi, 'rho': rho, 'T': T, 'r': r}
    }
    
    return local_vol, is_valid, diagnostics


def analyze_local_volatility_properties(k_values, local_vol, is_valid, model_name="Unknown"):
    """
    Analyze mathematical properties of the computed local volatility.
    
    Parameters
    ----------
    k_values : ndarray
        Log-moneyness values.
    local_vol : ndarray
        Computed local volatility values.
    is_valid : ndarray
        Boolean array indicating valid local volatility points.
    model_name : str, optional
        Name of the model for reporting.
    
    Returns
    -------
    analysis : dict
        Dictionary containing analysis results.
    """
    analysis = {
        'model_name': model_name,
        'total_points': len(k_values),
        'valid_points': np.sum(is_valid),
        'invalid_points': np.sum(~is_valid),
        'validity_percentage': 100 * np.sum(is_valid) / len(k_values)
    }
    
    if np.any(is_valid):
        valid_local_vol = local_vol[is_valid]
        valid_k = k_values[is_valid]
        
        analysis.update({
            'min_local_vol': np.min(valid_local_vol),
            'max_local_vol': np.max(valid_local_vol),
            'atm_local_vol': _interpolate_atm_value(valid_k, valid_local_vol),
            'local_vol_range': np.max(valid_local_vol) - np.min(valid_local_vol),
            'mean_local_vol': np.mean(valid_local_vol),
            'std_local_vol': np.std(valid_local_vol)
        })
        
        # Check for negative or infinite values
        analysis['has_negative'] = np.any(valid_local_vol < 0)
        analysis['has_infinite'] = np.any(np.isinf(valid_local_vol))
        analysis['has_nan'] = np.any(np.isnan(valid_local_vol))
        
        # Identify problematic regions
        if analysis['invalid_points'] > 0:
            invalid_k = k_values[~is_valid]
            analysis['invalid_k_range'] = [np.min(invalid_k), np.max(invalid_k)]
    else:
        analysis.update({
            'min_local_vol': np.nan,
            'max_local_vol': np.nan,
            'atm_local_vol': np.nan,
            'local_vol_range': np.nan,
            'mean_local_vol': np.nan,
            'std_local_vol': np.nan,
            'has_negative': False,
            'has_infinite': False,
            'has_nan': False
        })
    
    return analysis


def _interpolate_atm_value(k_values, values):
    """Helper function to interpolate value at ATM (k=0)."""
    if len(k_values) == 0:
        return np.nan
    
    # Find closest points to k=0
    abs_k = np.abs(k_values)
    min_idx = np.argmin(abs_k)
    
    if abs_k[min_idx] < 1e-6:  # Very close to ATM
        return values[min_idx]
    
    # Linear interpolation if we have points on both sides of 0
    positive_mask = k_values > 0
    negative_mask = k_values < 0
    
    if np.any(positive_mask) and np.any(negative_mask):
        # Find closest points on each side
        pos_k = k_values[positive_mask]
        pos_vals = values[positive_mask]
        neg_k = k_values[negative_mask]
        neg_vals = values[negative_mask]
        
        closest_pos_idx = np.argmin(pos_k)
        closest_neg_idx = np.argmax(neg_k)  # Closest to 0 from negative side
        
        k1, v1 = neg_k[closest_neg_idx], neg_vals[closest_neg_idx]
        k2, v2 = pos_k[closest_pos_idx], pos_vals[closest_pos_idx]
        
        # Linear interpolation
        return v1 + (v2 - v1) * (0 - k1) / (k2 - k1)
    else:
        # Return closest available value
        return values[min_idx]


def compare_implied_vs_local_volatility(k_values, T, svi_params=None, ssvi_params=None, r=0.0):
    """
    Compare implied and local volatilities for SVI and/or SSVI models.
    
    Parameters
    ----------
    k_values : ndarray
        Log-moneyness values.
    T : float
        Time to maturity.
    svi_params : dict, optional
        SVI parameters: {'a', 'b', 'rho', 'm', 'sigma'}.
    ssvi_params : dict, optional
        SSVI parameters: {'theta', 'phi', 'rho'}.
    r : float, optional
        Risk-free interest rate.
    
    Returns
    -------
    comparison : dict
        Comparison results containing implied vols, local vols, and analysis.
    """
    from svi_models import compute_svi_volatility_smile
    
    comparison = {'k_values': k_values, 'T': T, 'r': r}
    
    if svi_params is not None:
        # SVI model
        svi_implied_vol = compute_svi_volatility_smile(k_values, T, **svi_params)
        svi_local_vol, svi_is_valid, svi_diagnostics = compute_svi_local_volatility(
            k_values, T, **svi_params, r=r
        )
        
        comparison['svi'] = {
            'implied_vol': svi_implied_vol,
            'local_vol': svi_local_vol,
            'is_valid': svi_is_valid,
            'diagnostics': svi_diagnostics,
            'analysis': analyze_local_volatility_properties(k_values, svi_local_vol, svi_is_valid, "SVI")
        }
    
    if ssvi_params is not None:
        # SSVI model
        from svi_models import compute_ssvi_total_variance
        ssvi_total_var = compute_ssvi_total_variance(k_values, **ssvi_params)
        ssvi_implied_vol = np.sqrt(ssvi_total_var / T)
        
        ssvi_local_vol, ssvi_is_valid, ssvi_diagnostics = compute_ssvi_local_volatility(
            k_values, T, **ssvi_params, r=r
        )
        
        comparison['ssvi'] = {
            'implied_vol': ssvi_implied_vol,
            'local_vol': ssvi_local_vol,
            'is_valid': ssvi_is_valid,
            'diagnostics': ssvi_diagnostics,
            'analysis': analyze_local_volatility_properties(k_values, ssvi_local_vol, ssvi_is_valid, "SSVI")
        }
    
    return comparison


def print_local_volatility_analysis(analysis):
    """Print a formatted analysis of local volatility properties."""
    print(f"\n=== {analysis['model_name']} Local Volatility Analysis ===")
    print(f"Total points: {analysis['total_points']}")
    print(f"Valid points: {analysis['valid_points']} ({analysis['validity_percentage']:.1f}%)")
    print(f"Invalid points: {analysis['invalid_points']}")
    
    if analysis['valid_points'] > 0:
        print(f"Local volatility range: {analysis['min_local_vol']:.4f} - {analysis['max_local_vol']:.4f}")
        print(f"ATM local volatility: {analysis['atm_local_vol']:.4f}")
        print(f"Mean local volatility: {analysis['mean_local_vol']:.4f}")
        print(f"Std local volatility: {analysis['std_local_vol']:.4f}")
        
        if analysis.get('invalid_k_range'):
            print(f"Invalid region: k ∈ [{analysis['invalid_k_range'][0]:.3f}, {analysis['invalid_k_range'][1]:.3f}]")
        
        # Warning flags
        if analysis['has_negative']:
            print("⚠️  WARNING: Negative local volatilities detected!")
        if analysis['has_infinite']:
            print("⚠️  WARNING: Infinite local volatilities detected!")
        if analysis['has_nan']:
            print("⚠️  WARNING: NaN local volatilities detected!")
    else:
        print("❌ No valid local volatility points computed!")
    
    print()
